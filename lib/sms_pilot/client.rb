# frozen_string_literal: true

require "http"
require "uri"

module SmsPilot

  API_ENDPOINT = "https://smspilot.ru/api.php".freeze

  # @!attribute [r] api_key
  #   @return [String] Your API key
  #
  # @attr_reader [String] error Error description returned by the API
  # @attr_reader [String] phone Phone you sent the SMS to
  # @attr_reader [String] url URL generated by combining <tt>API_ENDPOINT</tt>, your API key, SMS text & phone
  #
  class Client

    attr_reader :api_key
    attr_reader :error
    attr_reader :phone
    attr_reader :response_body
    attr_reader :response_data
    attr_reader :response_headers
    attr_reader :response_status
    attr_reader :url


    # @param api_key [String]
    # @return [SmsPilot::Client]
    # @raise [TypeError] if you pass anything but a String
    # @raise [ArgumentError] if your API key is empty
    #
    def initialize(api_key:)
      fail TypeError, "API key must be a String, you pass a #{api_key.class} (#{api_key})" unless api_key.is_a? String
      fail TypeError, "API key cannot be empty" if api_key == ""

      @api_key          = api_key
      @error            = nil
      @response_status  = nil
      @response_headers = nil
      @response_body    = nil
      @response_data    = {}
      @url              = nil
    end


    # Send HTTP request to the API to ask them to transmit your SMS
    #
    # @return [Boolean] <tt>true</tt> if the SMS has been sent, <tt>false</tt> otherwise
    #
    # @param [String] phone The phone to send the SMS to. In free-form, will be sanitized.
    # @param [String] text The text of your message.
    #
    # @raise [TypeError] if you pass anythig but a String with the <tt>phone</tt> argument
    # @raise [TypeError] if you pass anythig but a String with the <tt>text</tt> argument
    # @raise [ArgumentError] if your text is empty
    # @raise [ArgumentError] if your phone is empty
    # @raise [ArgumentError] if your phone has no digits
    #
    def send_sms(phone, text)
      fail TypeError, "`phone` must be a String, you pass a #{phone.class} (#{phone})" unless phone.is_a? String
      fail TypeError,  "`text` must be a String, you pass a #{ text.class} (#{ text})" unless text.is_a? String
      fail ArgumentError, "`phone` cannot be empty" if phone == ""
      fail ArgumentError,  "`text` cannot be empty" if  text == ""
      fail ArgumentError, "`phone` must contain digits" if phone.scan(/\d/).none?

      @phone = normalize_phone(phone)
      @url   = build_url(@phone, text)

      response = HTTP.timeout(connect: 15, read: 30).accept(:json).get(@url)
      @response_status  = response.status.code
      @response_headers = response.headers.to_h
      @response_body    = response.body.to_s

      unless response.status.success?
        @error = "HTTP request failed with code #{response.status.code}"
        return false
      end

      @response_data = JSON.parse @response_body

      return @error = "#{error_description} (код ошибки: #{error_code})" if rejected?
      return true

    rescue JSON::ParserError => error
      @error = "API returned invalid JSON. #{error.message}"

    rescue HTTP::Error => error
      @error = error.message

    rescue => error
      @error = error.message
    end

    # Your current balance, remaining after sending that latest SMS.
    #
    # @return [nil, Float] Always <tt>nil</tt> before you send SMS and if the SMS was not sent, always Float after successfull SMS transmission.
    #
    def balance
      @response_data["balance"]&.to_f if sms_sent?
    end


    # Numerical code of the error that occured when sending the SMS
    #
    # @return [nil, Integer] <tt>nil</tt> is returned before sending SMS. Otherwise <tt>Integer</tt>
    # @see #error
    # @see https://smspilot.ru/apikey.php#err Error codes at the API documentation website
    #
    def error_code
      @response_data.dig("error", "code")&.to_i if rejected?
    end


    # Description of the error that occured when sending the SMS
    #
    # @return [nil, String] <tt>nil</tt> is returned before sending SMS. Otherwise <tt>String</tt>
    # @see #error
    # @see https://smspilot.ru/apikey.php#err Error codes at the API documentation website
    #
    def error_description
      @response_data.dig("error", "description_ru") if rejected?
    end


    # Did the API reject your request to send that SMS
    #
    # @return [Boolean] <tt>false</tt> is returned before sending SMS. Otherwise the <tt>Boolean</tt> correcponds to whether your request to send an SMS was rejected.
    #
    def rejected?
      return false if sms_sent?
      @response_data["error"].is_a? Hash
    end


    # Did the API block you
    #
    # Error code | Description
    # :---|:------------------
    # 105 | из-за низкого баланса
    # 106 | за спам/ошибки
    # 107 | за недостоверные учетные данные / недоступна эл. почта / проблемы с телефоном
    # 122 | спорная ситуация
    #
    # @return [Boolean] <tt>nil</tt> is returned before sending SMS. Otherwise the <tt>Boolean</tt> correcponds to whether the API has blocked you.
    # @see #error
    # @see https://smspilot.ru/apikey.php#err Error codes at the API documentation website
    #
    def sender_blocked?
      [105, 106, 107, 122].include? error_code
    end


    # The cost of the SMS that has just been sent
    #
    # @return [nil, Integer]
    #
    def sms_cost
      @response_data["cost"] if sms_sent?
    end


    # Has the SMS transmission been a success.
    #
    # @return [Boolean] <tt>nil</tt> is returned before sending SMS. Otherwise the <tt>Boolean</tt> correcponds to the result of SMS transmission.
    # @see #sms_status
    # @see #rejected?
    # @see #error
    #
    def sms_sent?
      @response_data["send"] != nil
    end


    # SMS delivery status, as returned by the API
    #
    # @return [nil, Integer] <tt>nil</tt> is returned before sending SMS or if the request was rejected. Otherwise an <tt>Integer</tt> in the range of [-2..3] is returned.
    # @see https://smspilot.ru/apikey.php#status List of available statuses at API documentation website
    #
    def sms_status
      @response_data.dig("send", 0, "status")&.to_i if sms_sent?
    end


    private

    def build_url(phone, text)
      URI.parse(API_ENDPOINT).tap do |url|
        url.query = URI.encode_www_form({ apikey: @api_key, format: :json, send: text, to: phone })
      end.to_s
    end

    def normalize_phone(phone)
      phone.gsub(/[^0-9]/, '').sub(/^8/, '7').gsub('+7', '8')
    end

  end
end
